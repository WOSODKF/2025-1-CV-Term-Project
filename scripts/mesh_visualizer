#!/bin/python3
import os
import sys

script_dir = os.path.dirname(os.path.realpath(__file__))
sys.path.append(script_dir)

import rospy
import numpy as np
import yaml
import cv2
from cv_project.msg import mesh, robotMeasurement
from geometry_msgs.msg import Point
from visualization_msgs.msg import Marker
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
from utils.math_utils import *

TO_ORIGINAL = False
TO_MASK = True

def get_camera_p(cam_K, measurement_msg:robotMeasurement):
    cam_pos = np.array([measurement_msg.cam_pos.x, measurement_msg.cam_pos.y, measurement_msg.cam_pos.z])
    cam_quat = np.array([measurement_msg.cam_quat.w, measurement_msg.cam_quat.x, measurement_msg.cam_quat.y, measurement_msg.cam_quat.z])
    cam_rot = quat_to_mat(cam_quat)

    T_cs = np.zeros((4,4))
    T_cs[:3,:3] = cam_rot.transpose()
    T_cs[:3,3] = -cam_rot.transpose() @ cam_pos
    T_cs[3,3] = 1

    I_0 = np.zeros((3,4))
    I_0[:3,:3] = np.identity(3)

    return cam_K @ I_0 @ T_cs

class CameraParameters:
    def __init__(self, config_dir):
        with open(config_dir, 'r') as file:
            config = yaml.safe_load(file)

        self.fov = config['camera']['fovy']
        self.width = config['camera']['width']
        self.height = config['camera']['height']
        self.focal_pixel = self.height/ (2*np.tan(self.fov/2 * np.pi / 180))
        cx = self.width/2
        cy = self.height/2
        self.cam_K = np.array([
            [-self.focal_pixel, 0, cx],
            [0, self.focal_pixel, cy],
            [0, 0, 1]
        ])

class MeasurementSubscriber:
    def __init__(self, vis_id):
        self.meas_sub = rospy.Subscriber("/simulator/measurement_"+str(vis_id), robotMeasurement, self.callback)
        self.last_msg = robotMeasurement()

    def callback(self, msg:robotMeasurement):
        self.last_msg = msg

class ViewSubscriber:
    def __init__(self, vis_id):
        self.cam_sub = rospy.Subscriber("/simulator/view_"+str(vis_id), Image, self.callback)
        self.last_msg = Image()

    def callback(self, msg:Image):
        self.last_msg = msg

class MaskSubscriber:
    def __init__(self, mask_id):
        self.mask_sub = rospy.Subscriber("/segmentor/seg_vis_"+str(mask_id), Image, self.callback)
        self.last_msg = Image()
        self.last_msg.encoding = "mono8"
        self.ready = False
    
    def callback(self, msg:Image):
        self.last_msg = msg
        self.ready = True

class MeshVisualizer:
    def __init__(self):
        rospy.init_node("mesh_visualizer_rviz")
        self.gt_sub = rospy.Subscriber("/simulator/mesh_GT", mesh, self.gt_callback)
        self.gt_marker_pub = rospy.Publisher("/GT_mesh_marker", Marker, queue_size=1)
        self.frame_id = rospy.get_param("~frame_id", "world")

        self.est_sub = rospy.Subscriber("/mesh_estimator/mesh_estimated", mesh, self.est_callback)
        self.est_marker_pub = rospy.Publisher("/Est_mesh_marker", Marker, queue_size=1)
        self.frame_id = rospy.get_param("~frame_id", "world")

        # for projection test
        self.agent_num = rospy.get_param("~agent_num")
        config_dir = rospy.get_param("~param")
        self.cam_param = CameraParameters(config_dir)
        self.meas_sub = []
        self.view_sub = []
        self.mask_sub = []
        self.gt_proj_pub = []
        self.est_proj_pub = []
        for vis_id in range(self.agent_num):
            self.meas_sub.append(MeasurementSubscriber(vis_id))
            self.view_sub.append(ViewSubscriber(vis_id))
            self.mask_sub.append(MaskSubscriber(vis_id))
            self.gt_proj_pub.append(rospy.Publisher("/GT_mesh_cam_projection_"+str(vis_id), Image, queue_size=1))
            self.est_proj_pub.append(rospy.Publisher("/est_mesh_cam_projection_"+str(vis_id), Image, queue_size=1))
        self.bridge = CvBridge()
        self.project_onto_original = TO_ORIGINAL
        self.project_onto_mask = TO_MASK
        
        # for correction test(see mesh_estimator->_corr_mesh)
        with open(config_dir, 'r') as file:
            config = yaml.safe_load(file)
        if config["sim"]["separate_corr_mesh"]:
            self.corr_sub = rospy.Subscriber("/mesh_estimator/mesh_corrected", mesh, self.corr_callback)
            self.corr_marker_pub = rospy.Publisher("Corr_mesh_marker", Marker, queue_size=1)
            

    def generate_markers(self, msg:mesh, is_estimate=False, is_corr=False):
        rows, cols = msg.rows, msg.cols
        if len(msg.positions) != rows * cols:
            rospy.logwarn("Mesh size mismatch")
            return

        # Reshape to 2D array for easier access
        positions = np.array([[p.x, p.y, p.z] for p in msg.positions])
        positions = positions.reshape((rows, cols, 3))

        marker = Marker()
        marker.header = msg.header
        # marker.header.frame_id = self.frame_id
        marker.header.frame_id = "map"
        marker.ns = "cloth_mesh"
        marker.id = 0
        marker.type = Marker.LINE_LIST
        marker.action = Marker.ADD
        marker.scale.x = 0.005  # line width

        if is_estimate:
            marker.color.r = 0.8
            marker.color.g = 0.2
            marker.color.b = 1.0
            marker.color.a = 1.0
        elif is_corr:
            marker.color.r = 0.8
            marker.color.g = 0.4
            marker.color.b = 0.2
            marker.color.a = 1.0
        else:
            marker.color.r = 0.2
            marker.color.g = 0.8
            marker.color.b = 1.0
            marker.color.a = 1.0

        marker.points = []

        # Horizontal lines
        for i in range(rows):
            for j in range(cols - 1):
                p1 = Point(*positions[i, j])
                p2 = Point(*positions[i, j + 1])
                marker.points.append(p1)
                marker.points.append(p2)

        # Vertical lines
        for i in range(rows - 1):
            for j in range(cols):
                p1 = Point(*positions[i, j])
                p2 = Point(*positions[i + 1, j])
                marker.points.append(p1)
                marker.points.append(p2)

        return marker

    def project_points_to_cam(self, msg:mesh, vis_id, to_original=False, to_mask=False):
        # construct camera matrix
        proj_msg = Image()
        view_msg = self.view_sub[vis_id].last_msg
        mask_msg = self.mask_sub[vis_id].last_msg
        measurement_msg = self.meas_sub[vis_id].last_msg

        if view_msg.header.stamp.to_sec() == 0:
            return Image()

        # if (measurement_msg.header.stamp - msg.header.stamp).to_sec() > 0.01:
        #     print("mesh-cam time mismatch at")
        #     print(f"cam: {measurement_msg.header.stamp.to_sec()}, mesh: {msg.header.stamp.to_sec()}")

        cam_P = get_camera_p(self.cam_param.cam_K, measurement_msg)
        if to_original:
            projection = self.bridge.imgmsg_to_cv2(view_msg).copy()
            color = (0, 255, 255)
            encoding = "bgr8"
        elif to_mask:
            gray_mask = self.bridge.imgmsg_to_cv2(mask_msg, "mono8").copy()  # mono8 image
            projection = cv2.cvtColor(gray_mask, cv2.COLOR_GRAY2BGR)  # convert to bgr8
            color = (0, 255, 255)
            encoding = "bgr8"
        else:
            projection = np.zeros((self.cam_param.height, self.cam_param.width), dtype=np.uint8)
            color = 255
            encoding = "mono8"

        positions = [np.array([p.x, p.y, p.z, 1]) for p in msg.positions]
        for p in positions:
            proj_pos = cam_P @ p

            if abs(proj_pos[2])>0.01:
                proj_pos /= proj_pos[2]
            else:
                continue

            col = round(proj_pos[0])
            row = round(proj_pos[1])

            if col > self.cam_param.width or row > self.cam_param.height:
                continue

            cv2.circle(projection, (col, row), 5, color, -1)
            
        proj_msg = self.bridge.cv2_to_imgmsg(projection, encoding)
        return proj_msg


    def gt_callback(self, msg:mesh):
        # generate marker and publish
        marker = self.generate_markers(msg, is_estimate=False)
        self.gt_marker_pub.publish(marker)

        # project points to camera and publish
        for vis_id in range(self.agent_num):
            if self.project_onto_mask and not self.mask_sub[vis_id].ready:
                continue
            projection = self.project_points_to_cam(msg, vis_id, self.project_onto_original, self.project_onto_mask)
            self.gt_proj_pub[vis_id].publish(projection)

    def est_callback(self, msg:mesh):
        # print(msg.positions)
        marker = self.generate_markers(msg, is_estimate=True)
        self.est_marker_pub.publish(marker)

        for vis_id in range(self.agent_num):
            if self.project_onto_mask and not self.mask_sub[vis_id].ready:
                continue
            projection = self.project_points_to_cam(msg, vis_id, self.project_onto_original, self.project_onto_mask)
            self.est_proj_pub[vis_id].publish(projection)

    def corr_callback(self, msg:mesh):
        # print(msg.positions)
        marker = self.generate_markers(msg, is_corr=True)
        self.corr_marker_pub.publish(marker)

    def run(self):
        rospy.spin()

if __name__ == "__main__":
    MeshVisualizer().run()